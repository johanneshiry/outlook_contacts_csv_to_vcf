/*
 * This source file was generated by the Gradle 'init' task
 */
package com.johanneshiry

import ezvcard.{Ezvcard, VCard}
import ezvcard.property.{Kind, StructuredName, Telephone}

import scala.util.Try
import kantan.csv.*
import kantan.csv.ops.*

import java.io.File
import java.nio.file.{Files, Paths}
import java.time.LocalDate
import scala.collection.immutable // Enriches types with useful methods.

object App {
  def main(args: Array[String]): Unit = {

    val csvPath: String = ???
    val outputPath: String = ???

    val mappedRows = readCsvFile(
      csvPath
    )

    val vCards =
      mappedRows.map(rows => rows.map(createVcard)).map(mergeVCardDuplicates)

    vCards.foreach(_.foreach { vCard =>
      val file = Paths.get(
        s"$outputPath/${vCard.getFormattedName.getValue.replace(" ", "").replace("/", " ")}.vcf"
      )
      Files.createFile(file)

      Ezvcard.write(vCard).go(file)
    })

  }

  private def mergeVCardDuplicates(vcards: Seq[VCard]): Seq[VCard] = {
    import scala.jdk.CollectionConverters._
    vcards
      .groupBy(_.getFormattedName.getValue)
      .values
      .map { duplicates =>
        if (duplicates.size == 1) duplicates.head
        else {
          val base = duplicates.head
          duplicates.tail.foreach { other =>
            // Merge Emails
            other.getEmails.asScala.foreach(e =>
              if (!base.getEmails.asScala.exists(_.getValue == e.getValue))
                base.addEmail(e)
            )
            // Merge Telephones
            other.getTelephoneNumbers.asScala.foreach(t =>
              if (
                !base.getTelephoneNumbers.asScala.exists(_.getText == t.getText)
              ) base.addTelephoneNumber(t)
            )
            // Merge Addresses
            other.getAddresses.asScala.foreach(a =>
              if (!base.getAddresses.asScala.exists(_.equals(a)))
                base.addAddress(a)
            )
            // Merge Notes
            other.getNotes.asScala.foreach(n =>
              if (!base.getNotes.asScala.exists(_.getValue == n.getValue))
                base.addNote(n)
            )
            // Merge URLs
            other.getUrls.asScala.foreach(u =>
              if (!base.getUrls.asScala.exists(_.getValue == u.getValue))
                base.addUrl(u)
            )
            // Merge IMs
            other.getImpps.asScala.foreach(im =>
              if (!base.getImpps.asScala.exists(_.getUri == im.getUri))
                base.addImpp(im)
            )
            // Merge Extended Properties
            other.getExtendedProperties.asScala.foreach(ep =>
              if (
                !base.getExtendedProperties.asScala.exists(x =>
                  (x.getPropertyName == ep.getPropertyName && x.getValue == ep.getValue)
                )
              ) then base.addExtendedProperty(ep.getPropertyName, ep.getValue)
            )
            // Merge structured names (if missing fields)
            val baseN = base.getStructuredName
            val otherN = other.getStructuredName
            if (baseN.getFamily == null && otherN.getFamily != null)
              baseN.setFamily(otherN.getFamily)
            if (baseN.getGiven == null && otherN.getGiven != null)
              baseN.setGiven(otherN.getGiven)
            otherN.getAdditionalNames.asScala.foreach(an =>
              if (!baseN.getAdditionalNames.asScala.contains(an))
                baseN.getAdditionalNames.add(an)
            )
            otherN.getPrefixes.asScala.foreach(p =>
              if (!baseN.getPrefixes.asScala.contains(p))
                baseN.getPrefixes.add(p)
            )
            otherN.getSuffixes.asScala.foreach(s =>
              if (!baseN.getSuffixes.asScala.contains(s))
                baseN.getSuffixes.add(s)
            )
          }
          base
        }
      }
      .toSeq
  }

  private def createVcard(row: Map[String, String]) = {

    import ezvcard.VCard
    import ezvcard.property._
    import ezvcard.parameter._

    val vcard = new VCard()

    // ---------------------------
    // Structured name (N)
    // ---------------------------
    val n = new StructuredName()
    row.get("Last Name").filter(_.trim.nonEmpty).foreach(n.setFamily)
    row.get("First Name").filter(_.trim.nonEmpty).foreach(n.setGiven)
    // middle name -> ADDITIONAL NAMES
    row
      .get("Middle Name")
      .filter(_.trim.nonEmpty)
      .foreach(m => n.getAdditionalNames.add(m))
    // prefix/title -> use prefixes list
    row.get("Title").filter(_.trim.nonEmpty).foreach(t => n.getPrefixes.add(t))
    // suffix -> suffixes list
    row.get("Suffix").filter(_.trim.nonEmpty).foreach(s => n.getSuffixes.add(s))
    vcard.setStructuredName(n)

    // Formatted name (FN) - build from parts if present
    val formatted = Seq(
      row.getOrElse("Title", ""),
      row.getOrElse("First Name", ""),
      row.getOrElse("Middle Name", ""),
      row.getOrElse("Last Name", ""),
      row.getOrElse("Suffix", ""),
    ).map(_.trim).filter(_.nonEmpty).mkString(" ")
    if (formatted.nonEmpty) vcard.setFormattedName(formatted)
    if (formatted.isEmpty)
      if (row.contains("Company"))
        vcard.setKind(Kind.org())
        vcard.setFormattedName(row.get("Company").map(_.trim).mkString(" "))
      else vcard.setKind(Kind.individual())

    // Nickname (NICKNAME)
    row
      .get("Nickname")
      .filter(_.trim.nonEmpty)
      .foreach(nick => vcard.setNickname(nick))

    // ---------------------------
    // Phonetic / Yomi fields -> use extended properties (X-...)
    // ez-vcard provides setExtendedProperty/addExtendedProperty for X- props.
    // ---------------------------
    row
      .get("Given Yomi")
      .filter(_.trim.nonEmpty)
      .foreach(v => vcard.setExtendedProperty("X-PHONETIC-FIRST-NAME", v))
    row
      .get("Surname Yomi")
      .filter(_.trim.nonEmpty)
      .foreach(v => vcard.setExtendedProperty("X-PHONETIC-LAST-NAME", v))
    row
      .get("Company Yomi")
      .filter(_.trim.nonEmpty)
      .foreach(v => vcard.setExtendedProperty("X-PHONETIC-ORG", v))

    // ---------------------------
    // Emails
    // - Treat first email as WORK. Accept either "E-mail Address" or
    // "E-mail 1 Address" as the first email header (both are handled).
    // ---------------------------
    def addEmailIfPresent(key: String, types: EmailType*): Unit =
      row.get(key).map(_.trim).filter(_.nonEmpty).foreach { email =>
        if (types.isEmpty) vcard.addEmail(email)
        else vcard.addEmail(email, types: _*)
      }

    addEmailIfPresent("E-mail Address", EmailType.WORK) // common header
    addEmailIfPresent(
      "E-mail 1 Address",
      EmailType.WORK,
    ) // alternate header name (tolerate both)
    addEmailIfPresent("E-mail 2 Address")
    addEmailIfPresent("E-mail 3 Address")

    // ---------------------------
    // Telephone numbers
    // Use Telephone property; mark primary phone using setPref(1).
    // For "Mobile Phone" we add both CELL and WORK to signal "Mobile (Business)".
    // ---------------------------
    def addTel(key: String, telTypes: TelephoneType*)(
        pref: Option[Int] = None
    ): Unit =
      row.get(key).map(_.trim).filter(_.nonEmpty).foreach { num =>
        val tel = new Telephone(num)
        telTypes.foreach(t => tel.getTypes.add(t))
        pref.foreach(tel.setPref(_))
        vcard.addTelephoneNumber(tel)
      }

    addTel("Home Phone", TelephoneType.HOME)()
    addTel("Home Phone 2", TelephoneType.HOME)()
    addTel("Business Phone", TelephoneType.WORK)()
    addTel("Business Phone 2", TelephoneType.WORK)()
    // Mobile as Mobile (Business) -> both CELL and WORK
    addTel("Mobile Phone", TelephoneType.CELL, TelephoneType.WORK)()
    addTel("Car Phone", TelephoneType.CAR)()
    addTel("Other Phone", TelephoneType.WORK)()
    // Primary phone: mark preference (PREF=1)
    addTel("Primary Phone", TelephoneType.VOICE)(pref = Some(1))
    addTel("Pager", TelephoneType.PAGER)()
    addTel("Business Fax", TelephoneType.FAX)()
    addTel("Home Fax", TelephoneType.FAX)()
    addTel("Other Fax", TelephoneType.FAX)()
    addTel("Company Main Phone", TelephoneType.WORK)()
    addTel("Callback", TelephoneType.VOICE)()
    addTel("Radio Phone", TelephoneType.VOICE)()
    addTel("Telex")()
    addTel("TTY/TDD Phone")()
    addTel("Assistant's Phone", TelephoneType.WORK)()

    // ---------------------------
    // IM / Instant messaging (IMPP)
    // ---------------------------
    row.get("IMAddress").map(_.trim).filter(_.nonEmpty).foreach { im =>
      // Impp constructors / factories exist in ez-vcard; create and add.
      vcard.addImpp(new Impp(im))
    }

    // ---------------------------
    // Job / Company / Department / Title / Manager / Assistant
    // ---------------------------
    row.get("Job Title").filter(_.trim.nonEmpty).foreach(t => vcard.addTitle(t))
    // Organization: setOrganization(company, department) is a convenience method.
    val companyOpt = row.get("Company").map(_.trim).filter(_.nonEmpty)
    val deptOpt = row.get("Department").map(_.trim).filter(_.nonEmpty)
    (companyOpt, deptOpt) match {
      case (Some(c), Some(d)) => vcard.setOrganization(c, d)
      case (Some(c), None)    => vcard.setOrganization(c)
      case _                  => ()
    }
    row
      .get("Office Location")
      .filter(_.trim.nonEmpty)
      .foreach(loc => vcard.setExtendedProperty("X-OFFICE-LOCATION", loc))
    row
      .get("Manager's Name")
      .filter(_.trim.nonEmpty)
      .foreach(m => vcard.setExtendedProperty("X-MANAGER", m))
    row
      .get("Assistant's Name")
      .filter(_.trim.nonEmpty)
      .foreach(a => vcard.setExtendedProperty("X-ASSISTANT", a))

    // ---------------------------
    // Addresses (Business / Home / Other)
    // ---------------------------
    def addAddress(prefix: String, addrType: AddressType): Unit =
      row.get(s"${prefix} Street").map(_.trim).filter(_.nonEmpty).foreach { _ =>
        val adr = new Address()
        adr.setStreetAddress(row.getOrElse(s"${prefix} Street", null))
        adr.setLocality(row.getOrElse(s"${prefix} City", null))
        adr.setRegion(row.getOrElse(s"${prefix} State", null))
        adr.setPostalCode(row.getOrElse(s"${prefix} Postal Code", null))
        adr.setCountry(row.getOrElse(s"${prefix} Country/Region", null))
        adr.getTypes.add(addrType)
        vcard.addAddress(adr)
      }

    addAddress("Business", AddressType.WORK)
    addAddress("Home", AddressType.HOME)
    addAddress("Other", AddressType.POSTAL)

    // ---------------------------
    // URLs / Web Pages
    // ---------------------------
    row.get("Personal Web Page").filter(_.trim.nonEmpty).foreach(vcard.addUrl)
    row.get("Web Page").filter(_.trim.nonEmpty).foreach(vcard.addUrl)

    // ---------------------------
    // Misc fields
    // ---------------------------
    row
      .get("Spouse")
      .filter(_.trim.nonEmpty)
      .foreach(s => vcard.setExtendedProperty("X-SPOUSE", s))
    row
      .get("Schools")
      .filter(_.trim.nonEmpty)
      .foreach(s => vcard.addInterest(s))
    row.get("Hobby").filter(_.trim.nonEmpty).foreach(h => vcard.addHobby(h))
    row
      .get("Location")
      .filter(_.trim.nonEmpty)
      .foreach(l => vcard.setExtendedProperty("X-LOCATION", l))

    // --- Notes ---
    row.get("Notes").filter(_.trim.nonEmpty).foreach { noteText =>
      vcard.addNote(noteText)
      // --- Extra: extract phone number from note and add as mobile ---
      val mobilePattern = """Firm issued mobile:\s*(\\+?\\d+)""".r
      mobilePattern.findFirstMatchIn(noteText).foreach { m =>
        val number = m.group(1)
        val tel = new Telephone(number)
        tel.getTypes.add(TelephoneType.CELL)
        tel.getTypes.add(TelephoneType.WORK)
        vcard.addTelephoneNumber(tel)
      }
    }

    // ---------------------------
    // Dates: Birthday / Anniversary
    // - Try ISO parsing; if parsing fails, the value is skipped. You can adapt the date
    // parser to match your CSV date format(s).
    // ---------------------------
    def parseDate(s: String): Option[LocalDate] = Try(
      LocalDate.parse(s)
    ).toOption

    row.get("Birthday").flatMap(parseDate).foreach(vcard.setBirthday)
    row.get("Anniversary").flatMap(parseDate).foreach(vcard.setAnniversary)

    vcard.setUid(Uid.random)
    vcard.setRevision(Revision.now)

    vcard
  }

  private def readCsvFile(
      filePath: String
  ): Option[Seq[Map[String, String]]] = {

    val readingResult = new File(filePath).asCsvReader[List[String]](rfc).toSeq

    readingResult.headOption
      .map {
        case Left(value) => Seq.empty[Map[String, String]]
        case Right(head) =>
          val trimmedHead = head.map(_.trim.replace("\uFEFF", ""))
          readingResult.tail.map {
            case Left(value) => Map.empty[String, String]
            case Right(row) =>
              trimmedHead.zip(row).toMap
          }
      }
  }

}
